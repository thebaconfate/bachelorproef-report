\documentclass[a4paper]{article}

% Load the VUB package.
% This has many options, please read the documentation at
% https://gitlab.com/rubdos/texlive-vub
\usepackage{vub}
\usepackage[english]{babel}

% Some highly suggested packages, please read their manuals.
\usepackage{hyperref}
\usepackage{float}
\usepackage{cleveref}
\usepackage[natbib, style=apa]{biblatex} %perhaps use ieee style? 
\usepackage{csquotes}
\addbibresource{bibliography.bib}
\setlength\parskip{\baselineskip}

\title{Python on the edge}
\pretitle{\flushleft{Graduation thesis submitted in partial fulfilment of the requirements for the degree of bachelor in de Wetenschappen: Computerwetenschappen}}
%\subtitle{my thesis subtitle}
\author{GÃ©rard Lichtert}
\date{\today}
\promotors{Promotors: Prof.\ Dr.\ Joeri de Koster and Prof.\ Dr.\ Wolfgang de Meuter. \and Advisor: Mathijs Saey}
\faculty{Sciences and bioengineering sciences}

\begin{document}
\maketitle
\tableofcontents
\newpage
\raggedright{}


\section{Introduction}
In a world of electronics and machines where power consumption is always increasing, we must do our best to optimize power consumption. This because electricity is expensive and while there is research being done to make energy generation more efficient, we can still do our part in optimizing the energy consumption to put less strain on the power generation. In the world of distributed computing, according to \cite{cloudcomputingenergycrisis} cloud computing takes 1\% of worldwide energy consumption. While this may not seem like much, it is still a significant amount of energy, and we want to do our part to decrease this percentage. While the end goal is to reduce the energy consumption for distributed programs, or more specifically IoT systems, where the generated data gets aggregated on the server in the cloud. We will be looking at reducing the energy consumption of the network traffic caused by transmitting data from the IoT devices to the cloud.

In IoT systems, the IoT devices, or sensors, are responsible for generating data. This data is then sent to the server for processing. Naturally this means that there is extra network traffic caused by the IoT devices. \cite{differentnetworkneedsiot} predicted that \enquote{IoT devices will account for 50\% of all networked devices by 2023}. This also means that there is an increase in energy consumption due to the necessary infrastructure required for the increase in data volume, as stated in \cite{datavolumeeffects}. What if we could reduce the network traffic by applying the edge-computing principle to the IoT systems? Meaning that prior to the IoT device sending the data to the cloud, it processes it locally first and then sends the preprocessed data to the cloud. This would mean that not all the data has to be sent but rather a subset of it. Logically this should reduce the total network traffic and the required energy. But what if this is not the optimal configuration? What if it is more beneficial to have some parts processed on the IoT devices and some part processed on the server? Or what if it is more beneficial to have some sensors process the data and then send it to the cloud and other sensors to send the data directly to the cloud? To try these different configurations we require a tool that allows us to easily deploy the distributed system and easily change the configuration of the deployment as well as configure where what gets processed. In this thesis we will be focusing on this deployment tool. We will start with the following goals:
\begin{enumerate}
    \item We want to be able to easily deploy the distributed system
    \item We want to be able easily allow us to change the configuration of the deployment
    \item We want to be able easily allow us to declare which data gets processed where
\end{enumerate}
However, prior to achieving these goals, we need to do some preparatory work. We need a suitable distributed computing paradigm, a programming language of implementation and possibly a framework in which we can create the tool. To start off with, we will look at the distributed computing paradigm.
\section{Preparation}
\subsection{Choosing a distributed computing paradigm}
To start with distributed computing, or our IoT systems we have to look for a suitable distributed computing paradigm that allows our system to be deployed from the cloud without much manual configuration, yet is able to do what we require it to do. We have several options, such as:
\begin{enumerate}
    \item Message Passing Interface (MPI) as described in \cite{MPI}
    \item Remote Procedure Call (RPC) as described in \cite{RPC}
    \item Shared Memory Model as described in \cite{SMM}
    \item The Actor Model as described in \cite{ActorModel}
    \item Publish/Subscribe (Pub/Sub) as described in \cite{PubSub}
\end{enumerate}
While each paradigm has their strengths and drawbacks, we will be using the Actor Model. Primarily because its modularity. Each actor encapsulates its state and behavior, which makes it a prime candidate to encapsulate the behavior of our IoT devices. Furthermore, using the Actor Model we can split our data processing pipeline into segments, each segment being captured by a different Actor. This allows us to easily move part of the data processing pipeline to the IoT devices or back to the server. This contributes to one of our previously stated goals: We want to be able to easily allow us to declare which data gets processed where. Other than the modularity, we also choose it for its maintainability. Since each part of the system is encapsulated in an Actor, we can easily change the behavior of parts of the system, instead of having to change our entire system. Another reason is scalability. We are able to distribute actors across different systems and machines. Which makes it perfect for IoT systems. Fault-tolerance makes it easier to contain errors and within individual actors and not propagate this to the entire system. The asynchronous nature of the Actor Model allows us to sparely use resources as needed, which will presumably reduce the required energy of the system. Lastly, through the message-based communication between Actors, we can easily decouple components, which in turn makes it easier to debug and test our systems. This is beneficial because distributed systems can quickly become very complex.
\subsection{Choosing a programming language}
The next step is to choose a programming language. Before we start looking for a suitable programming language, we need to look at what requirements the language has to fulfill. First and most importantly we need a programming language that can run on IoT devices. Otherwise, we would not be able to deploy our system on the IoT devices. Secondly, we need a programming language that supports the Actor Model, since we have chosen this as our distributed computing paradigm. 
\printbibliography
\end{document}
